import datetime
import time
from decimal import *
import threading


from endstone.command import Command, CommandSender
from endstone.event import EventPriority, ServerLoadEvent, event_handler
from endstone.plugin import Plugin
import yfinance as yf
yf.set_config(proxy="127.0.0.1:5555")

from endstone_up_and_down.databaseManager import DatabaseManager
from endstone_up_and_down.customWebsocket import CustomWebsocket
from endstone_up_and_down.stockDao import StockDao
from endstone_up_and_down.lockManager import LockException, LockManager, LockWithTimeout
from endstone_up_and_down.marketStatusListenr import MarketStatusListener


class UpAndDownPlugin(Plugin):
    prefix = "UpAndDown"
    api_version = "0.6"
    load = "POSTWORLD"

    commands = {
        "stock":{
                    "description": "Working on it",
                    "usages": ["/stock show [stockName: string]",
                               "/stock account",
                               "/stock transferin [amount:int]",
                               "/stock transferout [amount:int]",
                               "/stock buy [stockName: string] [share:int] [price:float]",
                               "/stock sell [stockName: string] [share:int] [price:float]",
                               "/stock orders [page:int]",
                               "/stock sleep"
                               ],
                    "permissions": ["up_and_down.command.transaction"]
                }
    }

    permissions = {
        "up_and_down.command.transaction": {
            "description": "Working on it",
            "default": True,
        }
    }
    
    order_type_dict = {
        "buy_flex": "市价单购买",
        "buy_fix": "限价单购买",
        "sell_flex": "市价单出售",
        "sell_fix": "限价单出售"
    }

    def on_load(self) -> None:
        self.database_manager = DatabaseManager("up_and_down.db")
        self.stock_dao = StockDao(self.database_manager)
        self.stock_dao.init_tables()
        self.economy_plugin = self.server.plugin_manager.get_plugin('arc_core')
        self.lock_manager = LockManager()
        
        self.logger.info("§e Up and down Loaded!")
        self.market_state_listener = MarketStatusListener("AAPL")
        self.market_state_listener.start_listen()
        

    def on_enable(self) -> None:
        pass
        # self.logger.info("on_enable is called!")
        # self.get_command("python").executor = PythonCommandExecutor()

        # self.register_events(self)  # register event listeners defined directly in Plugin class
        # self.register_events(ExampleListener(self))  # you can also register event listeners in a separate class

        # self.server.scheduler.run_task(self, self.log_time, delay=0, period=20 * 1)  # every second

    def on_disable(self) -> None:
        pass
        # self.logger.info("on_disable is called!")

    def on_command(self, sender: CommandSender, command: Command, args: list[str]) -> bool:
        '''
            Command router
        '''
    
        def command_executor():
            try:
                player = self.server.get_player(sender.name)
                xuid = player.xuid
                
                command_dict = {
                    "show": self.show,
                    "buy": self.buy_stock,
                    "sell": self.sell_stock,
                    "transferin": self.transfer_in,
                    "transferout": self.transfer_out,
                    "account": self.my_account,
                    "sleep": self.sleep_test,
                    "orders": self.show_orders
                }
                
                require_lock_command_list = ['buy', 'sell', 'transferin', 'transferout']
                
                command_func = command_dict[args[0]]
                
                if args[0] in require_lock_command_list:
                    uuid = self.server.get_player(sender.name).unique_id
                    player_lock = self.lock_manager.get_player_lock(str(uuid))
                    try:
                        with LockWithTimeout(player_lock, 1):
                            command_func(xuid, sender, args)
                    except LockException as ex:
                        sender.send_error_message("当前账号有其他股票操作正在进行，请稍候操作")
                else:
                    command_func(xuid, sender, args)
                    
                
            except Exception as e:
                import traceback
                exception = e
                exception_msg = str(e)
                full_traceback = traceback.format_exc()

                print("Exception Object:", exception)
                print("Exception Message:", exception_msg)
                print("Full Traceback:")
                print(full_traceback)
                
                sender.send_message(f"Exception Object:{exception}")
                sender.send_message(f"Exception Message:{exception_msg}")
                sender.send_message("Full Traceback:")
                sender.send_message(f"{full_traceback}")

        thread = threading.Thread(target=command_executor)
        thread.start()
        

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
    #
    #                     Common Utils
    #
    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 


    def is_available(self, ticket):
        return ticket.info['market'] in ['us_market']

    def get_stock_last_price(self, stock):
        '''
            Return price, tradeable
        '''

        ticket = yf.Ticker(stock)

        if not self.is_available(ticket):
            return None, self.market_state_listener.tradeable

        df = ticket.history(period="1d", interval="1m")
        price = round(df.Close.iloc[-1], 2)
        price = Decimal(str(price))
        
        return price, ticket.info['tradeable']
    

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
    #
    #                     Command Excutors
    #
    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
    def show(self, uuid, sender, args):
        '''
            Show stock price
        '''
        price, tradeable = self.get_stock_last_price(args[1])
        if price == None:
            sender.send_message(f"你输入了错误的股票名或该股票市场尚不支持:{args[1]}")
            return
        
        tradeable_msg = "开盘中" if tradeable else "休市中"
        
        sender.send_message(f"{args[1]} 昨日收盘价格: {price} ，交易状态：{tradeable_msg}")
        
        
    def transfer_in(self, uuid, sender, args):
        amount = float(args[1])
        player = self.server.get_player(sender.name)
        
        player_balance = self.economy_plugin.get_player_money(player)
        
        if player_balance < amount:
            sender.send_message(f"§e您的经济实力似乎不足以支付 {amount} 元")
            return
            
        self.economy_plugin.decrease_player_money(player, amount)
        self.stock_dao.increase_balance(uuid, amount)
        
        sender.send_message(f"§e成功向股票账户汇入 {amount} 元")
        
        
    def my_account(self, uuid, sender, args):
        player = self.server.get_player(sender.name)
        
        amount = self.stock_dao.get_balance(uuid)
        sender.send_message(f"§e股票账户余额 {amount} 元")
        
    
    def transfer_out(self, uuid, sender, args):
        # 获取转出金额

        amount = float(args[1])

        # 获取玩家对象
        player = self.server.get_player(sender.name)
        
        # 获取玩家股票账户余额
        stock_balance = self.stock_dao.get_balance(uuid)
        
        # 检查股票账户余额是否足够
        if stock_balance < amount:
            sender.send_message(f"§e您的股票账户余额不足，当前余额: {stock_balance} 元")
            return
        
        # 执行转账操作
        try:
            # 从股票账户扣除金额
            self.stock_dao.decrease_balance(uuid, amount)
            # 增加玩家游戏账户余额
            self.economy_plugin.increase_player_money(player, amount)
            
            sender.send_message(f"§e成功从股票账户转出 {amount} 元到游戏账户")
        except Exception as e:
            # 如果转账过程中出现错误，回滚操作
            sender.send_message("§e转账失败，请稍后重试")
            # 可以在这里添加日志记录
            print(f"Transfer out failed for player {uuid}: {str(e)}")
        
        
    def buy_stock(self, uuid, sender, args):
        '''
            Buy stock
        '''
        player = self.server.get_player(sender.name)
        stock_name = args[1]
        share = args[2]
        
        market_price, tradeable = self.get_stock_last_price(stock_name)
        if tradeable == None:
            sender.send_message(f"你输入了错误的股票名或该股票市场尚不支持:{args[1]}")
            return
        
        if len(args) == 4:
            price = Decimal(str(args[3]))
            type = "buy_fix"
        else:
            price = Decimal(str(market_price)) if tradeable else Decimal(0)
            type = "buy_flex"
            
        market_type = "实时交易" if tradeable else "盘后交易"
        
        order_id = self.stock_dao.create_order(uuid, stock_name, share, type)
        sender.send_message(f"订单创建成功，订单号: {order_id} 类型: {self.order_type_dict[type]} {market_type}")
        
        if tradeable:
            ws = CustomWebsocket()

            def message_handler(message):
                market_price = message["price"]

                if market_price <= price or type == "buy_flex":
                    if type == "buy_flex":
                        price = market_price
                    
                    ws.stop = True
                    total_price = price * share + (price * share * Decimal('0.02'))
                    if player_balance < total_price:
                        sender.send_message(f"您的经济实力似乎不足以支付 {total_price} 元")
                        return
                    
                    self.stock_dao.decrease_balance(uuid, total_price)
                    self.stock_dao.buy(order_id, stock_name, uuid, share, price)
                    sender.send_message(f"股票购买成功，总计:{total_price}元")    
                else:
                    pass
                        
            ws.subscribe(stock_name)
            
            # 开始监听（阻塞操作）
            ws.listen(message_handler)
        else:
            if price < market_price:
                sender.send_message(f"股票购买失败，当前市场价:{market_price}, 没有人愿意按您的报价{price}元购买")
                return
            player_balance = self.economy_plugin.get_player_money(player)
            
            share = Decimal(str(share))
            total_price = price * share + (price * share * Decimal('0.02'))
            if player_balance < total_price:
                sender.send_message(f"您的经济实力似乎不足以支付 {total_price} 元")
                return
            self.stock_dao.decrease_balance(uuid, total_price)
            self.stock_dao.buy(order_id, stock_name, uuid, share, price)
            sender.send_message(f"股票购买成功，总计:{total_price}元")    
            
            
    def sell_stock(self, uuid, sender, args):
        stock_name = args[1]
        share = Decimal(args[2])
        
        # 获取股票当前价格和可交易状态
        market_price, tradeable = self.get_stock_last_price(stock_name)
        if tradeable is None:
            sender.send_message(f"你输入了错误的股票名或该股票市场尚不支持:{args[1]}")
            return
        
        # 解析价格参数（限价单或市价单）
        if len(args) == 4:
            price = Decimal(str(args[3]))
            order_type = "sell_fix"
        else:
            price = Decimal(str(market_price)) if tradeable else Decimal(0)
            order_type = "sell_flex"
        
        # 检查玩家持股数量
        current_holding = self.stock_dao.get_player_stock_holding(uuid, stock_name)
        if current_holding < Decimal(share):
            sender.send_message(f"您的持股不足，当前持有 {current_holding} 股")
            return
        
        
        # 创建出售订单
        order_id = self.stock_dao.create_order(uuid, stock_name, share, order_type)
        market_type = "实时交易" if tradeable else "盘后交易"
        sender.send_message(f"订单创建成功，订单号: {order_id} 类型: {self.order_type_dict[order_type]} {market_type}")
        
        # 可交易股票处理（实时市场）
        if tradeable:
            ws = CustomWebsocket()
            def message_handler(message):
                market_price = Decimal(str(message["price"]))
                # 市价单直接成交，限价单等待价格达到目标
                if market_price >= price or order_type == "sell_flex":
                    if order_type == "sell_flex":
                        price = market_price
                    
                    ws.stop = True  # 停止监听
                    # 计算总收入（扣除2%手续费）
                    total_revenue = price * Decimal(share)
                    fee = total_revenue * Decimal('0.02')
                    net_revenue = total_revenue - fee
                    
                    # 执行交易
                    self.stock_dao.sell(order_id, stock_name, uuid, share, price)
                    self.stock_dao.increase_balance(uuid, net_revenue)
                    sender.send_message(f"股票出售成功，总计:{net_revenue}元")    
                else:
                    pass  # 价格未达到，继续等待
                    
            ws.subscribe(stock_name)
            ws.listen(message_handler)  # 阻塞监听
        
        # 不可交易股票处理（直接成交）
        else:
            # 检查市场价格是否满足限价要求
            if market_price < price:
                sender.send_message(
                    f"股票出售失败，当前市场价:{market_price}, "
                    f"没有人愿意按您的报价{price}元购买"
                )
                return
            
            # 计算总收入（扣除2%手续费）
            total_revenue = price * Decimal(share)
            fee = total_revenue * Decimal('0.02')
            net_revenue = total_revenue - fee
            
            # 执行交易
            self.stock_dao.sell(order_id, stock_name, uuid, share, price)
            self.stock_dao.increase_balance(uuid, net_revenue)
            sender.send_message(f"股票出售成功，总计:{net_revenue}元")  
            
    def sleep_test(self, uuid, sender, args):
        import time
        sender.send_message("Start")
        time.sleep(10)
        sender.send_message("Stop")
        
    def show_orders(self, uuid, sender, args):
        player = self.server.get_player(sender.name)
        
        if len(args) == 1:
            page = 0
        else:
            page = args[1]
            
        order_list = self.stock_dao.get_orders(uuid, page)
        
        message = ""
        for order in order_list:
            message += f"类型: {self.order_type_dict[order['type']]}\t"
            message += f'股票名: {order["stock_name"]}\t'
            message += f'股数: {order["share"]}\t'
            message += f'单价: {order["single_price"]}\t'
            message += f'手续费: {order["tax"]}\t'
            message += "\n"
            
        sender.send_message(message)
            


    @event_handler
    def on_server_load(self, event: ServerLoadEvent):
        self.logger.info(f"{event.event_name} is passed to on_server_load")

    @event_handler(priority=EventPriority.HIGH)
    def on_server_load_2(self, event: ServerLoadEvent):
        # this will be called after on_server_load because of a higher priority
        self.logger.info(f"{event.event_name} is passed to on_server_load2")

    def log_time(self):
        now = datetime.datetime.now().strftime("%c")
        for player in self.server.online_players:
            player.send_popup(now)
